\documentclass{article}
\usepackage{mathtools}
\usepackage[utf8]{inputenc}
\usepackage{multirow}
\usepackage{tocloft}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmic}


\floatname{algorithm}{Algorithme}

\renewcommand{\contentsname}{Table des matières}
\renewcommand{\tablename}{\Large Tableau}
\renewcommand{\cftsecfont}{\LARGE}
\renewcommand{\cftsubsecfont}{\Large}


\begin{document}
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        
        \Huge
        \textbf{INFO-F-203 - Rapport}
        
        \vspace{0.5cm}
        \LARGE
        Projet 1
        
        \vspace{1.5cm}
        
        \textbf{Yahya Bakkali\\}
        \Large
        Matricule : 445166\\
        
		\vspace{0.5cm}        
        
        \LARGE
        \textbf{Maxime Hauwaert\\}
        
		\Large        
        Matricule : 461714\\
        
        \vspace{0.8cm}

        Date : Novembre 2018
        
    \end{center}
\end{titlepage}

\setcounter{tocdepth}{3}
\tableofcontents
\newpage
\Large
	
\section{Introduction générale}
Ce projet a pour but de mettre en pratique des concepts sur les graphes vus au cours d’algorithmique 2 pour une meilleure compréhension et maîtrise de ceux-ci.

\section{Sous-arbre de poids maximum}
	\subsection{Introduction}
		Dans ce problème nous manipulons des arbres constitués de nœuds ayant un poids. Le problème consiste à transformer un arbre $T=(V,E)$ en arbre ${T'}=({V'},{E'})$ de façon à maximiser la fonction
		$$w({V'})=\sum_{v\in{V'}} w(v)$$

	\subsection{Choix d'implémentation}

		Nous avons décidé de ne pas modifier l'arbre de départ mais de créer une liste qui contiendra le nom de tous les nœuds à désactiver, pour qu'à l'affichage on puisse voir l'arbre de départ avec les nœuds activés (en rouge) ainsi que ceux désactivés (en gris).
	
	
		\subsection{Algorithme}
		
		\begin{algorithm}[H]
		\caption{maxContribution}
		\begin{algorithmic}[1]
		\REQUIRE liste nœuds\_à\_désactiver

		\STATE poids\_total = nœud.poids
	
		\FOR{chaque enfant du nœud}
	
		\IF{enfant.maxContribution()$<=$ 0}
		\STATE Ajouter enfant à nœuds\_à\_désactiver

		\ELSE
		\STATE Ajouter enfant.maxContribution() à poids\_total
	
		\ENDIF	
		\ENDFOR

		\RETURN poids\_total

		\end{algorithmic}
		\end{algorithm}
	
		La complexité de cet algorithme est de $O(n)$ car il parcourt chaque nœud de l'arbre, $O(n)$ et à chaque nœud $O(1)$. Donc la complexité finale est de $O(n)$.
		
	\subsection{Arbres aléatoires}
	Cette génération aléatoire d'arbres a une très bonne distribution. Tous les arbres sont possibles. Il y a  de 1 à n nœuds qui composeront l'arbre, 'n' étant 15 dans ce projet. Chaque nœud choisira tout simplement de qui il veut être l'enfant parmi les nœuds déja placés.
	
\section{Les hypergraphes et hypertrees}

	
	\subsection{Introduction}
	
	\subsection{Choix d'implémentation}
	
	\subsection{Algorithmes}
	
		\begin{algorithm}[H]
		\caption{find\_cliques}
		\begin{algorithmic}[1]
		\REQUIRE R : \{nœuds d'une clique maximale\}, P : \{nœuds possibles dans une clique maximale\}, X : \{nœuds exclus\}
		\IF{P et X sont vides}
		\IF{la clique R est de taille $>=$ 2}
		\STATE Ajouter R a la liste des cliques
		\ENDIF
		
		\ELSE
		
		\STATE pivot = élement aléatoire de l'ensemble $P \cup X $
		
		\FOR{chaque sommet S dans l'ensemble P $\setminus$ \{sommets liés au pivot\} }
		
		\STATE newP = P $\cap$ \{sommets liés à S\}
		\STATE newR = R $\cup$ \{S\}
		\STATE newX = X $\cap$ \{sommets liés à S\}
		\STATE find\_cliques(newP,newR,newX)
		
		\STATE P = P $\setminus$ \{S\}
		\STATE X = X $\cup$ \{S\}
		\ENDFOR		
		
		\ENDIF
	
	
		\end{algorithmic}
		\end{algorithm}

		\begin{algorithm}[H]
		\caption{is\_chordal}
		\begin{algorithmic}[1]		
		
		\STATE unnumbered = ensemble des sommets du graphe
		\STATE s = sommet choisi aléatoirement dans unnumbered
		\STATE unnumbered = unnumbered $\setminus$ \{s\}
		\STATE numbered  = \{s\}
		\WHILE{unnumbered $!=$ \{$\emptyset$\}}
			\STATE Vertex = le sommet de unumbered qui a le plus de connections aux sommets de numbered
			\STATE unnumbered = unnumbered - Vertex
			\STATE numbered = numbered + Vertex
			\STATE clique\_wanna\_be = \{sommets liés à Vertex\} $\cap$ numbered
			\STATE subGraph	= Un sous-graphe induit des sommets appartenant à clique\_wanna\_be
			\IF{le subGraph n'est pas complet}
				\RETURN False
			\ENDIF
		\ENDWHILE
		\RETURN True
		\end{algorithmic}
		\end{algorithm}

Au début, nous créons I , choisissons un sommet 
arbitraire I : O(N) , enlevons ce sommet du I : O(1) ,
créons II contenant ce sommet : O(1) .
Ensuite, tant que I n'est pas vide : O(N) nous chercherons
un sommet "Vertex" dans I qui a le plus de connexions aux sommets 
dans II : O(S x V x W) après nous supprimons ce sommet du I en 
l'ajoutant au II : O(1) puis créons un ensemble contenant 
l'intersection entre II et III : O(min(W,len(III))) et le 
sous-graphe induit à partir de cet ensemble : 
O(N x min(W,len(III)) x min(V,len(III)) ) .
Ce qui fait au final une complexité de
        O(N * max( min(W,len(III)) , N x min(W,len(III)) x min(V,len(III)) ))
    =   O(N ** 2 x min(W,len(III)) x min(V,len(III)) )\\
    
Statique :\\
III : ensemble des sommets liés au sommet "Vertex"\\
N : nombre de sommets du graphe \\
V : nombre de sommets d'une liste dans le dictionnaire\\

Dynamique :\\
I : ensemble des sommets du graphe "unnumbered"\\
II: ensemble des sommets "numbered"\\
S : nombre de sommets dans "unnumbered"\\
W : nombre de sommets dans "numbered"\\
		
		
		\begin{algorithm}[H]
		\caption{Algorithm\_X}
		\begin{algorithmic}[1]
		\REQUIRE Matrice
		
		\STATE Faire une copie de la matrice et exécuter l'algorithme sur cette matrice		
		\STATE Choisir la colonne C contenant un minimum de 1
		\STATE L = L'ensemble des lignes tel que $Matrice_{l,c}$ = 1, $\forall l \in L$
		\FOR{chaque ligne l de L}
			\STATE columnslist = []
			\STATE rowslist = []
			\STATE Ajouter la ligne à la solution partielle
			\FOR{chaque colonne j de la matrice}
				\IF{$Matrice_{l,j} = 1$}
					\FOR{chaque ligne i de la matrice}
						\IF{$Matrice_{i,j} = 1$}
							\STATE Ajouter la ligne i à rowlist
						\ENDIF									
					\ENDFOR
					\STATE Ajouter la colonne j de la matrice à columnslist	
				\ENDIF
			\ENDFOR
		\STATE Supprimer les lignes et les colonnes de la matrice présentes dans rowslist et columnslist
		\IF{la matrice n'est pas vide}
			\IF{toutes les colonnes de la matrice ont au moins un 1}
				\STATE Répéter cet algorithme de façon récursive sur la matrice réduite
			\ENDIF			
		\ELSE
			\STATE Ajouter la solution à l'ensemble des solutions
		\ENDIF 
		\STATE Supprimer la ligne de la solution partielle
		\STATE Réutiliser la matrice de départ
		\ENDFOR
	
		\end{algorithmic}
		\end{algorithm}
		
	
	\subsection{Hypergraphes aléatoires}
	
\section{Librairies utilisées}

	\subsection{Numpy}
		C'est une librairie très utile dans l'utilisation d'opérations mathématiques telles que les fonctions sinus/cosinus, etc ainsi que dans la manipulation de l'aléatoire.

	\subsection{Matplotlib}
		C'est une librairie assez utile dans l'affichage d'objets mathématiques en 2D tels que des cercles, des lignes, des graphiques, etc.
	
	\subsection{Copy}
		C'est une librairie permettant de copier l'intégralité d'un objet sans qu'il n'y ait de liens entre l'ancien et le nouvel objet.

\section{Conclusion}
	En plus de la simple mise en pratique de certains concepts sur les graphes, ce projet nous a permis de développer nos compétences de travail en groupe.

\end{document}